From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Davis Goodin <dagood@microsoft.com>
Date: Mon, 28 Aug 2023 16:39:33 -0500
Subject: [PATCH] Add backend sha3_356, hkdf print

---
 backend/nobackend.go     | 120 ++++++++++++++++++++++++++++++++
 backend/openssl_linux.go | 143 +++++++++++++++++++++++++++++++++++++++
 hkdf/hkdf.go             |   2 +
 sha3/hashes.go           |   9 +++
 4 files changed, 274 insertions(+)
 create mode 100644 backend/nobackend.go
 create mode 100644 backend/openssl_linux.go

diff --git a/backend/nobackend.go b/backend/nobackend.go
new file mode 100644
index 00000000000000..6e9c029a2063e6
--- /dev/null
+++ b/backend/nobackend.go
@@ -0,0 +1,120 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Do not edit the build constraint by hand. It is generated by "backendgen.go".
+
+//go:build !(goexperiment.boringcrypto && linux && cgo && (amd64 || arm64) && !android && !msan) && !(goexperiment.cngcrypto && windows) && !(goexperiment.opensslcrypto && linux && cgo)
+
+package backend
+
+import (
+	"crypto"
+	"crypto/cipher"
+	"hash"
+)
+
+const Enabled = false
+
+type BigInt = []uint
+
+type randReader int
+
+func (randReader) Read(b []byte) (int, error) { panic("cryptobackend: not available") }
+
+const RandReader = randReader(0)
+
+func NewSHA1() hash.Hash   { panic("cryptobackend: not available") }
+func NewSHA224() hash.Hash { panic("cryptobackend: not available") }
+func NewSHA256() hash.Hash { panic("cryptobackend: not available") }
+func NewSHA384() hash.Hash { panic("cryptobackend: not available") }
+func NewSHA512() hash.Hash { panic("cryptobackend: not available") }
+
+func NewSHA3_256() hash.Hash { panic("cryptobackend: not available") }
+
+func SHA1(p []byte) (sum [20]byte)   { panic("cryptobackend: not available") }
+func SHA224(p []byte) (sum [28]byte) { panic("cryptobackend: not available") }
+func SHA256(p []byte) (sum [32]byte) { panic("cryptobackend: not available") }
+func SHA384(p []byte) (sum [48]byte) { panic("cryptobackend: not available") }
+func SHA512(p []byte) (sum [64]byte) { panic("cryptobackend: not available") }
+
+func SHA3_256(p []byte) (sum [32]byte) { panic("cryptobackend: not available") }
+
+func NewHMAC(h func() hash.Hash, key []byte) hash.Hash { panic("cryptobackend: not available") }
+
+func NewAESCipher(key []byte) (cipher.Block, error) { panic("cryptobackend: not available") }
+func NewGCMTLS(c cipher.Block) (cipher.AEAD, error) { panic("cryptobackend: not available") }
+
+type PublicKeyECDSA struct{ _ int }
+type PrivateKeyECDSA struct{ _ int }
+
+func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+func NewPrivateKeyECDSA(curve string, X, Y, D BigInt) (*PrivateKeyECDSA, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
+	panic("cryptobackend: not available")
+}
+func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool {
+	panic("cryptobackend: not available")
+}
+
+type PublicKeyRSA struct{ _ int }
+type PrivateKeyRSA struct{ _ int }
+
+func DecryptRSAOAEP(h, mgfHash hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSAOAEP(h, mgfHash hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) {
+	panic("cryptobackend: not available")
+}
+func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+	panic("cryptobackend: not available")
+}
+func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+	panic("cryptobackend: not available")
+}
+
+type PublicKeyECDH struct{}
+type PrivateKeyECDH struct{}
+
+func ECDH(*PrivateKeyECDH, *PublicKeyECDH) ([]byte, error)    { panic("cryptobackend: not available") }
+func GenerateKeyECDH(string) (*PrivateKeyECDH, []byte, error) { panic("cryptobackend: not available") }
+func NewPrivateKeyECDH(string, []byte) (*PrivateKeyECDH, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyECDH(string, []byte) (*PublicKeyECDH, error) { panic("cryptobackend: not available") }
+func (*PublicKeyECDH) Bytes() []byte                          { panic("cryptobackend: not available") }
+func (*PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error)    { panic("cryptobackend: not available") }
diff --git a/backend/openssl_linux.go b/backend/openssl_linux.go
new file mode 100644
index 00000000000000..7fdcca37effffa
--- /dev/null
+++ b/backend/openssl_linux.go
@@ -0,0 +1,143 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.opensslcrypto && linux && cgo
+
+// Package openssl provides access to OpenSSLCrypto implementation functions.
+// Check the variable Enabled to find out whether OpenSSLCrypto is available.
+// If OpenSSLCrypto is not available, the functions in this package all panic.
+package backend
+
+import (
+	"hash"
+
+	_ "crypto/boring"
+	_ "unsafe"
+)
+
+// Enabled controls whether FIPS crypto is enabled.
+const Enabled = true
+
+//go:linkname RandReader crypto/internal/backend.RandReader
+var RandReader int
+
+// func NewSHA1() hash.Hash
+// func NewSHA224() hash.Hash
+// func NewSHA256() hash.Hash
+// func NewSHA384() hash.Hash
+// func NewSHA512() hash.Hash
+
+//go:linkname NewSHA3_256 crypto/internal/backend.NewSHA3_256
+func NewSHA3_256() hash.Hash
+
+// func SHA1(p []byte) (sum [20]byte)   { return openssl.SHA1(p) }
+// func SHA224(p []byte) (sum [28]byte) { return openssl.SHA224(p) }
+// func SHA256(p []byte) (sum [32]byte) { return openssl.SHA256(p) }
+// func SHA384(p []byte) (sum [48]byte) { return openssl.SHA384(p) }
+// func SHA512(p []byte) (sum [64]byte) { return openssl.SHA512(p) }
+
+//go:linkname SHA3_256 crypto/internal/backend.SHA3_256
+func SHA3_256(p []byte) (sum [32]byte)
+
+// func NewHMAC(h func() hash.Hash, key []byte) hash.Hash { return openssl.NewHMAC(h, key) }
+
+// func NewAESCipher(key []byte) (cipher.Block, error) { return openssl.NewAESCipher(key) }
+// func NewGCMTLS(c cipher.Block) (cipher.AEAD, error) { return openssl.NewGCMTLS(c) }
+
+// type PublicKeyECDSA = openssl.PublicKeyECDSA
+// type PrivateKeyECDSA = openssl.PrivateKeyECDSA
+
+// func GenerateKeyECDSA(curve string) (X, Y, D openssl.BigInt, err error) {
+// 	return openssl.GenerateKeyECDSA(curve)
+// }
+
+// func NewPrivateKeyECDSA(curve string, X, Y, D openssl.BigInt) (*openssl.PrivateKeyECDSA, error) {
+// 	return openssl.NewPrivateKeyECDSA(curve, X, Y, D)
+// }
+
+// func NewPublicKeyECDSA(curve string, X, Y openssl.BigInt) (*openssl.PublicKeyECDSA, error) {
+// 	return openssl.NewPublicKeyECDSA(curve, X, Y)
+// }
+
+// func SignMarshalECDSA(priv *openssl.PrivateKeyECDSA, hash []byte) ([]byte, error) {
+// 	return openssl.SignMarshalECDSA(priv, hash)
+// }
+
+// func VerifyECDSA(pub *openssl.PublicKeyECDSA, hash []byte, sig []byte) bool {
+// 	return openssl.VerifyECDSA(pub, hash, sig)
+// }
+
+// type PublicKeyRSA = openssl.PublicKeyRSA
+// type PrivateKeyRSA = openssl.PrivateKeyRSA
+
+// func DecryptRSAOAEP(h, mgfHash hash.Hash, priv *openssl.PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+// 	return openssl.DecryptRSAOAEP(h, mgfHash, priv, ciphertext, label)
+// }
+
+// func DecryptRSAPKCS1(priv *openssl.PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+// 	return openssl.DecryptRSAPKCS1(priv, ciphertext)
+// }
+
+// func DecryptRSANoPadding(priv *openssl.PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+// 	return openssl.DecryptRSANoPadding(priv, ciphertext)
+// }
+
+// func EncryptRSAOAEP(h, mgfHash hash.Hash, pub *openssl.PublicKeyRSA, msg, label []byte) ([]byte, error) {
+// 	return openssl.EncryptRSAOAEP(h, mgfHash, pub, msg, label)
+// }
+
+// func EncryptRSAPKCS1(pub *openssl.PublicKeyRSA, msg []byte) ([]byte, error) {
+// 	return openssl.EncryptRSAPKCS1(pub, msg)
+// }
+
+// func EncryptRSANoPadding(pub *openssl.PublicKeyRSA, msg []byte) ([]byte, error) {
+// 	return openssl.EncryptRSANoPadding(pub, msg)
+// }
+
+// func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv openssl.BigInt, err error) {
+// 	return openssl.GenerateKeyRSA(bits)
+// }
+
+// func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv openssl.BigInt) (*openssl.PrivateKeyRSA, error) {
+// 	return openssl.NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv)
+// }
+
+// func NewPublicKeyRSA(N, E openssl.BigInt) (*openssl.PublicKeyRSA, error) {
+// 	return openssl.NewPublicKeyRSA(N, E)
+// }
+
+// func SignRSAPKCS1v15(priv *openssl.PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+// 	return openssl.SignRSAPKCS1v15(priv, h, hashed)
+// }
+
+// func SignRSAPSS(priv *openssl.PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+// 	return openssl.SignRSAPSS(priv, h, hashed, saltLen)
+// }
+
+// func VerifyRSAPKCS1v15(pub *openssl.PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+// 	return openssl.VerifyRSAPKCS1v15(pub, h, hashed, sig)
+// }
+
+// func VerifyRSAPSS(pub *openssl.PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+// 	return openssl.VerifyRSAPSS(pub, h, hashed, sig, saltLen)
+// }
+
+// type PublicKeyECDH = openssl.PublicKeyECDH
+// type PrivateKeyECDH = openssl.PrivateKeyECDH
+
+// func ECDH(priv *openssl.PrivateKeyECDH, pub *openssl.PublicKeyECDH) ([]byte, error) {
+// 	return openssl.ECDH(priv, pub)
+// }
+
+// func GenerateKeyECDH(curve string) (*openssl.PrivateKeyECDH, []byte, error) {
+// 	return openssl.GenerateKeyECDH(curve)
+// }
+
+// func NewPrivateKeyECDH(curve string, bytes []byte) (*openssl.PrivateKeyECDH, error) {
+// 	return openssl.NewPrivateKeyECDH(curve, bytes)
+// }
+
+// func NewPublicKeyECDH(curve string, bytes []byte) (*openssl.PublicKeyECDH, error) {
+// 	return openssl.NewPublicKeyECDH(curve, bytes)
+// }
diff --git a/hkdf/hkdf.go b/hkdf/hkdf.go
index dda3f143bec506..8700f761b3b6de 100644
--- a/hkdf/hkdf.go
+++ b/hkdf/hkdf.go
@@ -13,6 +13,7 @@ package hkdf // import "golang.org/x/crypto/hkdf"
 import (
 	"crypto/hmac"
 	"errors"
+	"fmt"
 	"hash"
 	"io"
 )
@@ -88,6 +89,7 @@ func Expand(hash func() hash.Hash, pseudorandomKey, info []byte) io.Reader {
 // New returns a Reader, from which keys can be read, using the given hash,
 // secret, salt and context info. Salt and info can be nil.
 func New(hash func() hash.Hash, secret, salt, info []byte) io.Reader {
+	fmt.Println("This is a not-so-subtle modification to x/crypto that you got automatically!")
 	prk := Extract(hash, secret, salt)
 	return Expand(hash, prk, info)
 }
diff --git a/sha3/hashes.go b/sha3/hashes.go
index 0d8043fd2a173d..655853d8ae78c6 100644
--- a/sha3/hashes.go
+++ b/sha3/hashes.go
@@ -10,6 +10,8 @@ package sha3
 
 import (
 	"hash"
+
+	"golang.org/x/crypto/backend"
 )
 
 // New224 creates a new SHA3-224 hash.
@@ -26,6 +28,10 @@ func New224() hash.Hash {
 // Its generic security strength is 256 bits against preimage attacks,
 // and 128 bits against collision attacks.
 func New256() hash.Hash {
+	if backend.Enabled {
+		println("using backend sha3_256")
+		return backend.NewSHA3_256()
+	}
 	if h := new256Asm(); h != nil {
 		return h
 	}
@@ -74,6 +80,9 @@ func Sum224(data []byte) (digest [28]byte) {
 
 // Sum256 returns the SHA3-256 digest of the data.
 func Sum256(data []byte) (digest [32]byte) {
+	if backend.Enabled {
+		return backend.SHA3_256(data)
+	}
 	h := New256()
 	h.Write(data)
 	h.Sum(digest[:0])
